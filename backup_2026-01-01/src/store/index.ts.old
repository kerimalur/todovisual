import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { v4 as uuidv4 } from 'uuid';
import { 
  Goal, 
  Project, 
  Task, 
  CalendarEvent, 
  JournalEntry, 
  FocusSession,
  TimerState,
  ModalType,
  Habit,
  HabitCompletion,
  HabitCategoryItem
} from '@/types';

// ===== APP STATE STORE =====
interface AppState {
  sidebarCollapsed: boolean;
  zenModeActive: boolean;
  zenWorkspaceActive: boolean; // New: relaxed zen workspace mode
  currentModal: ModalType;
  fabMenuOpen: boolean;
  
  toggleSidebar: () => void;
  toggleZenMode: () => void;
  toggleZenWorkspace: () => void;
  setModal: (modal: ModalType) => void;
  setFabMenuOpen: (open: boolean) => void;
}

export const useAppStore = create<AppState>((set) => ({
  sidebarCollapsed: false,
  zenModeActive: false,
  zenWorkspaceActive: false,
  currentModal: null,
  fabMenuOpen: false,
  
  toggleSidebar: () => set((state) => ({ sidebarCollapsed: !state.sidebarCollapsed })),
  toggleZenMode: () => set((state) => ({ zenModeActive: !state.zenModeActive })),
  toggleZenWorkspace: () => set((state) => ({ zenWorkspaceActive: !state.zenWorkspaceActive })),
  setModal: (modal) => set({ currentModal: modal }),
  setFabMenuOpen: (open) => set({ fabMenuOpen: open }),
}));

// ===== TIMER STORE =====
interface TimerStore {
  timer: TimerState;
  startTimer: (minutes: number, taskId?: string) => void;
  pauseTimer: () => void;
  resumeTimer: () => void;
  stopTimer: () => void;
  tick: () => void;
}

export const useTimerStore = create<TimerStore>((set, get) => ({
  timer: {
    isRunning: false,
    isPaused: false,
    secondsRemaining: 0,
    totalSeconds: 0,
    currentTaskId: undefined,
    sessionId: undefined,
  },
  
  startTimer: (minutes, taskId) => set({
    timer: {
      isRunning: true,
      isPaused: false,
      secondsRemaining: minutes * 60,
      totalSeconds: minutes * 60,
      currentTaskId: taskId,
      sessionId: uuidv4(),
    }
  }),
  
  pauseTimer: () => set((state) => ({
    timer: { ...state.timer, isPaused: true }
  })),
  
  resumeTimer: () => set((state) => ({
    timer: { ...state.timer, isPaused: false }
  })),
  
  stopTimer: () => set({
    timer: {
      isRunning: false,
      isPaused: false,
      secondsRemaining: 0,
      totalSeconds: 0,
      currentTaskId: undefined,
      sessionId: undefined,
    }
  }),
  
  tick: () => set((state) => {
    if (state.timer.secondsRemaining <= 0) {
      return { timer: { ...state.timer, isRunning: false } };
    }
    return {
      timer: {
        ...state.timer,
        secondsRemaining: state.timer.secondsRemaining - 1
      }
    };
  }),
}));

// ===== DATA STORE =====
interface DataStore {
  goals: Goal[];
  projects: Project[];
  tasks: Task[];
  events: CalendarEvent[];
  journalEntries: JournalEntry[];
  focusSessions: FocusSession[];
  habits: Habit[];
  habitCategories: HabitCategoryItem[];

  // Performance indexes (O(1) lookups)
  _taskIndex: Map<string, Task>;
  _goalTasksIndex: Map<string, Task[]>;
  _projectTasksIndex: Map<string, Task[]>;

  // Index helpers
  rebuildIndexes: () => void;
  getTaskById: (id: string) => Task | undefined;
  getTasksByGoal: (goalId: string) => Task[];
  getTasksByProject: (projectId: string) => Task[];

  // Goal actions
  addGoal: (goal: Omit<Goal, 'id' | 'createdAt' | 'progress'>) => void;
  updateGoal: (id: string, updates: Partial<Goal>) => void;
  deleteGoal: (id: string) => void;

  // Project actions
  addProject: (project: Omit<Project, 'id' | 'createdAt'>) => void;
  updateProject: (id: string, updates: Partial<Project>) => void;
  deleteProject: (id: string) => void;

  // Task actions
  addTask: (task: Omit<Task, 'id' | 'createdAt'>) => Task;
  updateTask: (id: string, updates: Partial<Task>) => void;
  deleteTask: (id: string) => void;
  completeTask: (id: string) => void;
  reactivateTask: (id: string) => void;
  deleteCompletedTasks: () => void;

  // Archiving actions (NEW)
  archiveCompletedTasks: (olderThanDays?: number) => void;
  unarchiveTask: (id: string) => void;
  getArchivedTasks: () => Task[];
  permanentlyDeleteArchivedTasks: () => void;

  // Event actions
  addEvent: (event: Omit<CalendarEvent, 'id'>) => void;
  updateEvent: (id: string, updates: Partial<CalendarEvent>) => void;
  deleteEvent: (id: string) => void;

  // Journal actions
  addJournalEntry: (entry: Omit<JournalEntry, 'id'>) => void;
  updateJournalEntry: (id: string, updates: Partial<JournalEntry>) => void;
  deleteJournalEntry: (id: string) => void;

  // Session actions
  addFocusSession: (session: Omit<FocusSession, 'id'>) => void;
  completeFocusSession: (id: string, actualMinutes: number) => void;

  // Habit Category actions
  addHabitCategory: (category: Omit<HabitCategoryItem, 'id'>) => HabitCategoryItem;
  updateHabitCategory: (id: string, updates: Partial<HabitCategoryItem>) => void;
  deleteHabitCategory: (id: string) => void;

  // Habit actions
  addHabit: (habit: Omit<Habit, 'id' | 'createdAt' | 'currentStreak' | 'longestStreak' | 'totalCompletions' | 'completions'>) => Habit;
  updateHabit: (id: string, updates: Partial<Habit>) => void;
  deleteHabit: (id: string) => void;
  completeHabit: (id: string, date?: Date, value?: number, notes?: string) => void;
  uncompleteHabit: (id: string, date: Date) => void;
  pauseHabit: (id: string, until?: Date) => void;
  resumeHabit: (id: string) => void;
  isHabitCompletedToday: (id: string) => boolean;
  getHabitCompletionsThisWeek: (id: string) => number;
  calculateStreak: (habit: Habit) => number;
}

// Leere Initial-Daten (keine Dummy-Daten mehr)
const initialGoals: Goal[] = [];
const initialProjects: Project[] = [];
const initialTasks: Task[] = [];

// Helper: Build indexes from tasks
const buildIndexes = (tasks: Task[]) => {
  const taskIndex = new Map<string, Task>();
  const goalTasksIndex = new Map<string, Task[]>();
  const projectTasksIndex = new Map<string, Task[]>();

  tasks.forEach((task) => {
    // Task by ID
    taskIndex.set(task.id, task);

    // Tasks by Goal
    if (task.goalId) {
      const existing = goalTasksIndex.get(task.goalId) || [];
      goalTasksIndex.set(task.goalId, [...existing, task]);
    }

    // Tasks by Project
    if (task.projectId) {
      const existing = projectTasksIndex.get(task.projectId) || [];
      projectTasksIndex.set(task.projectId, [...existing, task]);
    }
  });

  return { taskIndex, goalTasksIndex, projectTasksIndex };
};

export const useDataStore = create<DataStore>()(
  persist(
    (set, get) => ({
      goals: initialGoals,
      projects: initialProjects,
      tasks: initialTasks,
      events: [],
      journalEntries: [],
      focusSessions: [],
      habits: [],
      habitCategories: [],

      // Initialize indexes
      _taskIndex: new Map(),
      _goalTasksIndex: new Map(),
      _projectTasksIndex: new Map(),

      // Rebuild indexes
      rebuildIndexes: () => {
        const { tasks } = get();
        const indexes = buildIndexes(tasks);
        set({
          _taskIndex: indexes.taskIndex,
          _goalTasksIndex: indexes.goalTasksIndex,
          _projectTasksIndex: indexes.projectTasksIndex,
        });
      },

      // Fast lookups (O(1))
      getTaskById: (id: string) => {
        return get()._taskIndex.get(id);
      },

      getTasksByGoal: (goalId: string) => {
        return get()._goalTasksIndex.get(goalId) || [];
      },

      getTasksByProject: (projectId: string) => {
        return get()._projectTasksIndex.get(projectId) || [];
      },
      
      // Goal actions
      addGoal: (goal) => set((state) => ({
        goals: [...state.goals, { 
          ...goal, 
          id: uuidv4(), 
          createdAt: new Date(),
          progress: 0 
        }]
      })),
      
      updateGoal: (id, updates) => set((state) => ({
        goals: state.goals.map((g) => g.id === id ? { ...g, ...updates } : g)
      })),
      
      deleteGoal: (id) => set((state) => ({
        goals: state.goals.filter((g) => g.id !== id),
        // Also delete related projects and tasks
        projects: state.projects.filter((p) => p.goalId !== id),
        tasks: state.tasks.filter((t) => t.goalId !== id),
      })),
      
      // Project actions
      addProject: (project) => set((state) => ({
        projects: [...state.projects, { 
          ...project, 
          id: uuidv4(), 
          createdAt: new Date() 
        }]
      })),
      
      updateProject: (id, updates) => set((state) => ({
        projects: state.projects.map((p) => p.id === id ? { ...p, ...updates } : p)
      })),
      
      deleteProject: (id) => set((state) => ({
        projects: state.projects.filter((p) => p.id !== id)
      })),
      
      // Task actions (with index rebuild)
      addTask: (task) => {
        const newTask: Task = {
          ...task,
          id: uuidv4(),
          createdAt: new Date(),
          tags: task.tags || [],
          priority: task.priority || 'medium',
          status: task.status || 'todo',
        } as Task;

        set((state) => {
          const updatedTasks = [...state.tasks, newTask];
          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        });

        return newTask;
      },

      updateTask: (id, updates) =>
        set((state) => {
          const updatedTasks = state.tasks.map((t) =>
            t.id === id ? { ...t, ...updates } : t
          );
          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        }),

      deleteTask: (id) =>
        set((state) => {
          const updatedTasks = state.tasks.filter((t) => t.id !== id);
          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        }),

      completeTask: (id) =>
        set((state) => {
          const updatedTasks = state.tasks.map((t) =>
            t.id === id
              ? { ...t, status: 'completed' as const, completedAt: new Date() }
              : t
          );
          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        }),

      reactivateTask: (id) =>
        set((state) => {
          const updatedTasks = state.tasks.map((t) =>
            t.id === id
              ? { ...t, status: 'todo' as const, completedAt: undefined }
              : t
          );
          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        }),

      deleteCompletedTasks: () =>
        set((state) => {
          const updatedTasks = state.tasks.filter((t) => t.status !== 'completed');
          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        }),

      // Archiving actions
      archiveCompletedTasks: (olderThanDays = 30) => {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);

        set((state) => {
          const tasksToArchive = state.tasks.filter(
            (t) =>
              t.status === 'completed' &&
              t.completedAt &&
              new Date(t.completedAt) <= cutoffDate
          );

          const updatedTasks = state.tasks.map((t) =>
            tasksToArchive.some((archived) => archived.id === t.id)
              ? { ...t, status: 'archived' as const, archivedAt: new Date() }
              : t
          );

          // Rebuild indexes after archive
          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        });
      },

      unarchiveTask: (id) =>
        set((state) => {
          const updatedTasks = state.tasks.map((t) =>
            t.id === id
              ? { ...t, status: 'todo' as const, archivedAt: undefined }
              : t
          );

          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        }),

      getArchivedTasks: () => {
        return get().tasks.filter((t) => t.status === 'archived');
      },

      permanentlyDeleteArchivedTasks: () =>
        set((state) => {
          const updatedTasks = state.tasks.filter((t) => t.status !== 'archived');
          const indexes = buildIndexes(updatedTasks);

          return {
            tasks: updatedTasks,
            _taskIndex: indexes.taskIndex,
            _goalTasksIndex: indexes.goalTasksIndex,
            _projectTasksIndex: indexes.projectTasksIndex,
          };
        }),

      // Event actions
      addEvent: (event) => set((state) => ({
        events: [...state.events, { ...event, id: uuidv4() }]
      })),
      
      updateEvent: (id, updates) => set((state) => ({
        events: state.events.map((e) => e.id === id ? { ...e, ...updates } : e)
      })),
      
      deleteEvent: (id) => set((state) => ({
        events: state.events.filter((e) => e.id !== id)
      })),
      
      // Journal actions
      addJournalEntry: (entry) => set((state) => ({
        journalEntries: [...state.journalEntries, { ...entry, id: uuidv4() }]
      })),
      
      updateJournalEntry: (id, updates) => set((state) => ({
        journalEntries: state.journalEntries.map((j) => 
          j.id === id ? { ...j, ...updates } : j
        )
      })),

      deleteJournalEntry: (id) => set((state) => ({
        journalEntries: state.journalEntries.filter((j) => j.id !== id)
      })),
      
      // Session actions
      addFocusSession: (session) => set((state) => ({
        focusSessions: [...state.focusSessions, { ...session, id: uuidv4() }]
      })),
      
      completeFocusSession: (id, actualMinutes) => set((state) => ({
        focusSessions: state.focusSessions.map((s) => 
          s.id === id 
            ? { ...s, status: 'completed' as const, actualMinutes, endTime: new Date() }
            : s
        )
      })),

      // ===== HABIT CATEGORY ACTIONS =====
      addHabitCategory: (category) => {
        const newCategory: HabitCategoryItem = {
          ...category,
          id: uuidv4(),
        };
        set((state) => ({
          habitCategories: [...state.habitCategories, newCategory]
        }));
        return newCategory;
      },

      updateHabitCategory: (id, updates) => set((state) => ({
        habitCategories: state.habitCategories.map((c) => c.id === id ? { ...c, ...updates } : c)
      })),

      deleteHabitCategory: (id) => set((state) => ({
        habitCategories: state.habitCategories.filter((c) => c.id !== id),
        // Also update habits with this category to 'uncategorized'
        habits: state.habits.map((h) => h.category === id ? { ...h, category: '' } : h)
      })),

      // ===== HABIT ACTIONS =====
      addHabit: (habit) => {
        const newHabit: Habit = {
          ...habit,
          id: uuidv4(),
          createdAt: new Date(),
          currentStreak: 0,
          longestStreak: 0,
          totalCompletions: 0,
          completions: [],
        };
        set((state) => ({
          habits: [...state.habits, newHabit]
        }));
        return newHabit;
      },

      updateHabit: (id, updates) => set((state) => ({
        habits: state.habits.map((h) => h.id === id ? { ...h, ...updates } : h)
      })),

      deleteHabit: (id) => set((state) => ({
        habits: state.habits.filter((h) => h.id !== id)
      })),

      completeHabit: (id, date = new Date(), value, notes) => set((state) => {
        const habit = state.habits.find(h => h.id === id);
        if (!habit) return state;

        // Prüfen ob heute schon erledigt
        const today = new Date(date);
        today.setHours(0, 0, 0, 0);
        const alreadyCompletedToday = habit.completions.some(c => {
          const completionDate = new Date(c.date);
          completionDate.setHours(0, 0, 0, 0);
          return completionDate.getTime() === today.getTime();
        });

        if (alreadyCompletedToday) return state;

        const newCompletion: HabitCompletion = {
          id: uuidv4(),
          date: new Date(),
          value,
          notes,
        };

        const newCompletions = [...habit.completions, newCompletion];
        
        // Streak berechnen
        const sortedCompletions = [...newCompletions].sort(
          (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
        );
        
        let streak = 1;
        let prevDate = new Date();
        prevDate.setHours(0, 0, 0, 0);
        
        for (let i = 1; i < sortedCompletions.length; i++) {
          const compDate = new Date(sortedCompletions[i].date);
          compDate.setHours(0, 0, 0, 0);
          
          const expectedPrevDate = new Date(prevDate);
          expectedPrevDate.setDate(expectedPrevDate.getDate() - 1);
          expectedPrevDate.setHours(0, 0, 0, 0);
          
          if (compDate.getTime() === expectedPrevDate.getTime()) {
            streak++;
            prevDate = compDate;
          } else {
            break;
          }
        }

        return {
          habits: state.habits.map((h) => 
            h.id === id 
              ? {
                  ...h,
                  completions: newCompletions,
                  totalCompletions: h.totalCompletions + 1,
                  currentStreak: streak,
                  longestStreak: Math.max(h.longestStreak, streak),
                }
              : h
          )
        };
      }),

      uncompleteHabit: (id, date) => set((state) => {
        const habit = state.habits.find(h => h.id === id);
        if (!habit) return state;

        const targetDate = new Date(date);
        targetDate.setHours(0, 0, 0, 0);

        const filteredCompletions = habit.completions.filter(c => {
          const compDate = new Date(c.date);
          compDate.setHours(0, 0, 0, 0);
          return compDate.getTime() !== targetDate.getTime();
        });

        return {
          habits: state.habits.map((h) =>
            h.id === id
              ? {
                  ...h,
                  completions: filteredCompletions,
                  totalCompletions: Math.max(0, h.totalCompletions - 1),
                }
              : h
          )
        };
      }),

      pauseHabit: (id, until) => set((state) => ({
        habits: state.habits.map((h) =>
          h.id === id ? { ...h, isPaused: true, pausedUntil: until } : h
        )
      })),

      resumeHabit: (id) => set((state) => ({
        habits: state.habits.map((h) =>
          h.id === id ? { ...h, isPaused: false, pausedUntil: undefined } : h
        )
      })),

      isHabitCompletedToday: (id) => {
        const habit = get().habits.find(h => h.id === id);
        if (!habit) return false;
        
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        return habit.completions.some(c => {
          const compDate = new Date(c.date);
          compDate.setHours(0, 0, 0, 0);
          return compDate.getTime() === today.getTime();
        });
      },

      getHabitCompletionsThisWeek: (id) => {
        const habit = get().habits.find(h => h.id === id);
        if (!habit) return 0;

        const now = new Date();
        const startOfWeek = new Date(now);
        const dayOfWeek = now.getDay();
        const diff = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Montag = Start
        startOfWeek.setDate(now.getDate() - diff);
        startOfWeek.setHours(0, 0, 0, 0);

        return habit.completions.filter(c => {
          const compDate = new Date(c.date);
          return compDate >= startOfWeek;
        }).length;
      },

      calculateStreak: (habit) => {
        if (habit.completions.length === 0) return 0;
        
        const sortedCompletions = [...habit.completions].sort(
          (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
        );

        // Prüfen ob heute oder gestern erledigt
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        const lastCompDate = new Date(sortedCompletions[0].date);
        lastCompDate.setHours(0, 0, 0, 0);

        if (lastCompDate.getTime() !== today.getTime() && lastCompDate.getTime() !== yesterday.getTime()) {
          return 0; // Streak gebrochen
        }

        let streak = 1;
        let prevDate = lastCompDate;

        for (let i = 1; i < sortedCompletions.length; i++) {
          const compDate = new Date(sortedCompletions[i].date);
          compDate.setHours(0, 0, 0, 0);

          const expectedPrevDate = new Date(prevDate);
          expectedPrevDate.setDate(expectedPrevDate.getDate() - 1);

          if (compDate.getTime() === expectedPrevDate.getTime()) {
            streak++;
            prevDate = compDate;
          } else {
            break;
          }
        }

        return streak;
      },
    }),
    {
      name: 'productivity-suite-data-v2', // Version 2 - fresh start without dummy data
      version: 2,
      migrate: (persistedState, version) => {
        // If coming from version 1 or no version, reset to empty
        if (version < 2) {
          return {
            goals: [],
            projects: [],
            tasks: [],
            events: [],
            journalEntries: [],
            focusSessions: [],
          };
        }
        return persistedState;
      },
    }
  )
);

// ===== MOTIVATION STORE =====
interface MotivationStore {
  showToast: boolean;
  currentMessage: string;
  triggerMotivation: (type: 'task-complete' | 'goal-reached' | 'timer-done' | 'zen-mode') => void;
  hideToast: () => void;
}

const motivationMessages = {
  'task-complete': [
    "Der einfache Weg war gestern. Gut gemacht.",
    "Eine Aufgabe weniger zwischen dir und deinem Ziel. Weiter.",
    "Du hast noch 40% im Tank. Hör auf zu jammern und mach die nächste Aufgabe.",
    "Schwäche verlässt den Körper. Nächste Aufgabe.",
    "Erledigt. Kein Applaus nötig. Nächste.",
  ],
  'goal-reached': [
    "Ein Ziel erreicht. Aber du weißt, dass es nie genug ist. Weiter.",
    "Gut. Aber ruh dich nicht aus. Der nächste Berg wartet.",
    "Du hast bewiesen, dass du kannst. Jetzt beweis es nochmal.",
  ],
  'timer-done': [
    "Session beendet. Dein Fokus-Muskel wird stärker.",
    "25 Minuten konzentrierte Arbeit. Das ist, was Champions tun.",
    "Niemand interessiert sich dafür, wie du dich fühlst. Nur Ergebnisse zählen. Weiter.",
  ],
  'zen-mode': [
    "Lärm aus. Fokus an. Zerstöre diese Aufgabe.",
    "Disziplin ist, wenn du es trotzdem machst. Fokus jetzt.",
    "Keine Ablenkungen. Keine Ausreden. Nur du und die Aufgabe.",
  ],
};

export const useMotivationStore = create<MotivationStore>((set) => ({
  showToast: false,
  currentMessage: '',
  
  triggerMotivation: (type) => {
    const messages = motivationMessages[type];
    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
    set({ showToast: true, currentMessage: randomMessage });
    
    setTimeout(() => {
      set({ showToast: false });
    }, 4000);
  },
  
  hideToast: () => set({ showToast: false }),
}));

// ===== SETTINGS STORE =====
interface UserSettings {
  // Profile
  name: string;
  email: string;
  avatar: string;
  
  // Timer & Focus
  defaultFocusMinutes: number;
  defaultBreakMinutes: number;
  longBreakMinutes: number;
  sessionsUntilLongBreak: number;
  autoStartBreaks: boolean;
  autoStartFocus: boolean;
  
  // Notifications
  soundEnabled: boolean;
  soundVolume: number;
  motivationToastsEnabled: boolean;
  dailyReminderEnabled: boolean;
  reminderTime: string;
  
  // Appearance
  theme: 'light' | 'dark' | 'system';
  accentColor: string;
  compactMode: boolean;
  showCompletedTasks: boolean;
  
  // Zen Mode
  zenShowClock: boolean;
  zenShowStats: boolean;
  zenShowQuotes: boolean;
  zenBackgroundStyle: 'solid' | 'gradient' | 'animated';
  
  // Calendar & Tasks
  weekStartsOnMonday: boolean;
  defaultTaskPriority: 'low' | 'medium' | 'high';
  showTaskDescriptions: boolean;
  
  // Data & Privacy
  language: 'de' | 'en';
  autoBackup: boolean;
  backupFrequency: 'daily' | 'weekly' | 'monthly';
}

interface SettingsStore {
  settings: UserSettings;
  updateSettings: (updates: Partial<UserSettings>) => void;
  resetSettings: () => void;
}

const defaultSettings: UserSettings = {
  // Profile
  name: '',
  email: '',
  avatar: '',
  
  // Timer & Focus
  defaultFocusMinutes: 25,
  defaultBreakMinutes: 5,
  longBreakMinutes: 15,
  sessionsUntilLongBreak: 4,
  autoStartBreaks: false,
  autoStartFocus: false,
  
  // Notifications
  soundEnabled: true,
  soundVolume: 80,
  motivationToastsEnabled: true,
  dailyReminderEnabled: false,
  reminderTime: '09:00',
  
  // Appearance
  theme: 'light',
  accentColor: '#2383e2',
  compactMode: false,
  showCompletedTasks: true,
  
  // Zen Mode
  zenShowClock: true,
  zenShowStats: true,
  zenShowQuotes: true,
  zenBackgroundStyle: 'solid',
  
  // Calendar & Tasks
  weekStartsOnMonday: true,
  defaultTaskPriority: 'medium',
  showTaskDescriptions: true,
  
  // Data & Privacy
  language: 'de',
  autoBackup: false,
  backupFrequency: 'weekly',
};

export const useSettingsStore = create<SettingsStore>()(
  persist(
    (set) => ({
      settings: defaultSettings,
      
      updateSettings: (updates) => set((state) => ({
        settings: { ...state.settings, ...updates }
      })),
      
      resetSettings: () => set({ settings: defaultSettings }),
    }),
    {
      name: 'settings-storage',
      version: 1,
    }
  )
);

